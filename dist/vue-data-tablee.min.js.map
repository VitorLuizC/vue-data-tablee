{"version":3,"file":"vue-data-tablee.min.js","sources":["../src/helpers/is.js","../src/helpers/validators.js","../src/helpers/get.js","../rollupPluginBabelHelpers","../src/mixins/Selectable.js","../src/mixins/Sortable.js","../src/DataTable.vue","../src/mixins/Alignable.js"],"sourcesContent":["/**\n * Check value's constructor name.\n * @param {*} value\n * @param {string} constructor\n * @returns {boolean}\n */\nexport default (value, constructor) => {\n  const is = Object.prototype.toString.call(value) === `[object ${constructor}]`\n  return is\n}\n","import is from './is'\n\n/**\n * Creates a validator function that checks is value is included in values.\n * @param {Array} values\n * @returns {function(*):boolean}\n */\nconst includes = (values) => (value) => values.includes(value)\n\nconst ALIGNMENTS = ['right', 'left', 'center']\n\n/**\n * Checks if value is an alignment.\n */\nexport const isAlignment = includes(ALIGNMENTS)\n\n/**\n * Checks if value is a list of objects.\n * @param {*} value\n * @returns {boolean}\n */\nexport const isContent = (value) => {\n  const isObject = (value) => is(value, 'Object')\n  const isContent = is(value, 'Array') && value.every(isObject)\n  return isContent\n}\n","import is from './is'\n\nconst DELIMITER = '.'\n\n/**\n * Spreads path into fields list.\n * @param {string} path\n * @returns {Array.<string>}\n */\nconst getProperties = (path) => is(path, 'String') ? path.split(DELIMITER) : []\n\n/**\n * Deep object.\n * @typedef {Object.<string, (number|boolean|string|Deep)>} Deep\n */\n\n/**\n * Checks if a propety is reachable.\n * @param {Deep} object\n * @param {string} property\n * @returns {(number|boolean|string|null)}\n */\nconst getValue = (object, property) => {\n  const isReachable = is(object, 'Object') && object.hasOwnProperty(property)\n  const value = isReachable ? object[property] : null\n  return value\n}\n\n/**\n * Get value from object path.\n * @param {Deep} object\n * @param {(string|Array.<string>)} path\n * @returns {(number|boolean|string|null)}\n */\nexport const get = (object, path) => {\n  const properties = getProperties(path)\n  const value = properties.reduce(getValue, object)\n  return value\n}\n\nconst DEFAULT_VALIDATE = (value) => !is(value, 'Null')\n\n/**\n * Get value from first object.\n * @param {string} name\n * @param {Deep[]} objects\n * @param {function(*):boolean} [validate]\n * @returns {*}\n */\nexport const getProperty = (name, objects, validate = DEFAULT_VALIDATE) => {\n  const properties = objects.map((object) => get(object, name))\n  const property = properties.find((property) => validate(property))\n  return property\n}\n\nexport default get\n","export { _typeof as typeof, _jsx as jsx, _asyncIterator as asyncIterator, _AwaitValue as AwaitValue, _AsyncGenerator as AsyncGenerator, _wrapAsyncGenerator as wrapAsyncGenerator, _awaitAsyncGenerator as awaitAsyncGenerator, _asyncGeneratorDelegate as asyncGeneratorDelegate, _asyncToGenerator as asyncToGenerator, _classCallCheck as classCallCheck, _createClass as createClass, _defineEnumerableProperties as defineEnumerableProperties, _defaults as defaults, _defineProperty as defineProperty, _extends as extends, _get as get, _inherits as inherits, _inheritsLoose as inheritsLoose, _wrapNativeSuper as wrapNativeSuper, _instanceof as instanceof, _interopRequireDefault as interopRequireDefault, _interopRequireWildcard as interopRequireWildcard, _newArrowCheck as newArrowCheck, _objectDestructuringEmpty as objectDestructuringEmpty, _objectWithoutProperties as objectWithoutProperties, _assertThisInitialized as assertThisInitialized, _possibleConstructorReturn as possibleConstructorReturn, _set as set, _slicedToArray as slicedToArray, _slicedToArrayLoose as slicedToArrayLoose, _taggedTemplateLiteral as taggedTemplateLiteral, _taggedTemplateLiteralLoose as taggedTemplateLiteralLoose, _temporalRef as temporalRef, _readOnlyError as readOnlyError, _classNameTDZError as classNameTDZError, _temporalUndefined as temporalUndefined, _toArray as toArray, _toConsumableArray as toConsumableArray, _skipFirstGeneratorNext as skipFirstGeneratorNext, _toPropertyKey as toPropertyKey, _initializerWarningHelper as initializerWarningHelper, _initializerDefineProperty as initializerDefineProperty, _applyDecoratedDescriptor as applyDecoratedDescriptor };\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar REACT_ELEMENT_TYPE;\n\nfunction _jsx(type, props, key, children) {\n  if (!REACT_ELEMENT_TYPE) {\n    REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  }\n\n  var defaultProps = type && type.defaultProps;\n  var childrenLength = arguments.length - 3;\n\n  if (!props && childrenLength !== 0) {\n    props = {\n      children: void 0\n    };\n  }\n\n  if (props && defaultProps) {\n    for (var propName in defaultProps) {\n      if (props[propName] === void 0) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  } else if (!props) {\n    props = defaultProps || {};\n  }\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = new Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 3];\n    }\n\n    props.children = childArray;\n  }\n\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key === undefined ? null : '' + key,\n    ref: null,\n    props: props,\n    _owner: null\n  };\n}\n\nfunction _asyncIterator(iterable) {\n  if (typeof Symbol === \"function\") {\n    if (Symbol.asyncIterator) {\n      var method = iterable[Symbol.asyncIterator];\n      if (method != null) return method.call(iterable);\n    }\n\n    if (Symbol.iterator) {\n      return iterable[Symbol.iterator]();\n    }\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(\"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n}\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new _AsyncGenerator(fn.apply(this, arguments));\n  };\n}\n\nfunction _awaitAsyncGenerator(value) {\n  return new _AwaitValue(value);\n}\n\nfunction _asyncGeneratorDelegate(inner, awaitWrap) {\n  var iter = {},\n      waiting = false;\n\n  function pump(key, value) {\n    waiting = true;\n    value = new Promise(function (resolve) {\n      resolve(inner[key](value));\n    });\n    return {\n      done: false,\n      value: awaitWrap(value)\n    };\n  }\n\n  ;\n\n  if (typeof Symbol === \"function\" && Symbol.iterator) {\n    iter[Symbol.iterator] = function () {\n      return this;\n    };\n  }\n\n  iter.next = function (value) {\n    if (waiting) {\n      waiting = false;\n      return value;\n    }\n\n    return pump(\"next\", value);\n  };\n\n  if (typeof inner.throw === \"function\") {\n    iter.throw = function (value) {\n      if (waiting) {\n        waiting = false;\n        throw value;\n      }\n\n      return pump(\"throw\", value);\n    };\n  }\n\n  if (typeof inner.return === \"function\") {\n    iter.return = function (value) {\n      return pump(\"return\", value);\n    };\n  }\n\n  return iter;\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          Promise.resolve(value).then(_next, _throw);\n        }\n      }\n\n      function _next(value) {\n        step(\"next\", value);\n      }\n\n      function _throw(err) {\n        step(\"throw\", err);\n      }\n\n      _next();\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineEnumerableProperties(obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n    for (var i = 0; i < objectSymbols.length; i++) {\n      var sym = objectSymbols[i];\n      var desc = descs[sym];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, sym, desc);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return _get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar _gPO = Object.getPrototypeOf || function _gPO(o) {\n  return o.__proto__;\n};\n\nvar _sPO = Object.setPrototypeOf || function _sPO(o, p) {\n  o.__proto__ = p;\n  return o;\n};\n\nvar _construct = typeof Reflect === \"object\" && Reflect.construct || function _construct(Parent, args, Class) {\n  var Constructor,\n      a = [null];\n  a.push.apply(a, args);\n  Constructor = Parent.bind.apply(Parent, a);\n  return _sPO(new Constructor(), Class.prototype);\n};\n\nvar _cache = typeof Map === \"function\" && new Map();\n\nfunction _wrapNativeSuper(Class) {\n  if (typeof Class !== \"function\") {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  if (typeof _cache !== \"undefined\") {\n    if (_cache.has(Class)) return _cache.get(Class);\n\n    _cache.set(Class, Wrapper);\n  }\n\n  function Wrapper() {}\n\n  Wrapper.prototype = Object.create(Class.prototype, {\n    constructor: {\n      value: Wrapper,\n      enumerable: false,\n      writeable: true,\n      configurable: true\n    }\n  });\n  return _sPO(Wrapper, _sPO(function Super() {\n    return _construct(Class, arguments, _gPO(this).constructor);\n  }, Class));\n}\n\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _newArrowCheck(innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n}\n\nfunction _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      _set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n}\n\nfunction _sliceIterator(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _slicedToArray(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    return _sliceIterator(arr, i);\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nfunction _slicedToArrayLoose(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  strings.raw = raw;\n  return strings;\n}\n\nfunction _temporalRef(val, name) {\n  if (val === _temporalUndefined) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n}\n\nfunction _readOnlyError(name) {\n  throw new Error(\"\\\"\" + name + \"\\\" is read-only\");\n}\n\nfunction _classNameTDZError(name) {\n  throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n}\n\nvar _temporalUndefined = {};\n\nfunction _toArray(arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _skipFirstGeneratorNext(fn) {\n  return function () {\n    var it = fn.apply(this, arguments);\n    it.next();\n    return it;\n  };\n}\n\nfunction _toPropertyKey(key) {\n  if (typeof key === \"symbol\") {\n    return key;\n  } else {\n    return String(key);\n  }\n}\n\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');\n}\n\nfunction _initializerDefineProperty(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}","const Selectable = ({ rows = 'rows' } = {}) => ({\n  props: {\n    selectable: Boolean\n  },\n\n  data () {\n    return {\n      selectedRows: [],\n      lastClicked: undefined\n    }\n  },\n\n  computed: {\n    isSelectedAll () {\n      const isNotEmpty = !!this[rows].length\n      const isEqualsLength = isNotEmpty && this[rows].length === this.selectedRows.length\n      const isSelectedAll = isEqualsLength && this[rows].every((row) => {\n        return this.selectedRows.includes(row)\n      })\n      return isSelectedAll\n    }\n  },\n\n  watch: {\n    rows () {\n      this.selectedRows = []\n    }\n  },\n\n  methods: {\n    /**\n     * Check if a row is selected.\n     * @param {object} row\n     * @returns {boolean}\n     */\n    isSelected (row) {\n      const isSelected = !!this.selectedRows.find((selected) => selected === row)\n      return isSelected\n    },\n\n    /**\n     * Set row active.\n     * @param {object} row\n     * @param {object} event\n     */\n    select (row, event) {\n      if (event.shiftKey && this.lastClicked !== row) {\n        this.multipleSelect(row)\n      } else {\n        this.selectedRows = this.isSelected(row)\n          ? this.selectedRows.filter((selected) => selected !== row)\n          : [ ...this.selectedRows, row ]\n      }\n      this.lastClicked = row\n      this.emitSelected()\n    },\n\n    /**\n     * Set multiple rows active.\n     * @param {object} row\n     */\n    multipleSelect (row) {\n      const s1 = this[rows].indexOf(row)\n      const s2 = this[rows].indexOf(this.lastClicked)\n      const [start, end] = [s1, s2].sort()\n      const range = Array(end - start + 1).fill().map((_, index) => start + index)\n      this.selectedRows = this[rows].filter((_, index) => range.includes(index))\n    },\n\n    /**\n     * Set all rows active.\n     * @param {Event} event\n     */\n    selectAll (event) {\n      this.selectedRows = this.isSelectedAll ? [] : [ ...this[rows] ]\n      this.emitSelected()\n    },\n\n    /**\n     * Emit selected rows.\n     */\n    emitSelected () {\n      this.$emit('select', this.selectedRows)\n    }\n  }\n})\n\nexport default Selectable\n","import is from '../helpers/is'\nimport get, { getProperty } from '../helpers/get'\n\n/**\n * Default sort function.\n * @param {(string|number)} a\n * @param {(string|number)} b\n * @returns {number}\n */\nconst DEFAULT_SORT = (a = '', b = '') => {\n  const isNumbers = is(a, 'Number') && is(b, 'Number')\n  if (isNumbers) {\n    return a - b\n  } else {\n    return String(a || '').localeCompare(String(b || ''))\n  }\n}\n\nconst Sortable = ({ cols = 'cols', rows = 'rows' } = {}) => ({\n  props: {\n    /**\n     * Defines if it sort and optionally define's default sort function.\n     */\n    sort: {\n      type: [Boolean, Function],\n      default: true\n    },\n\n    /**\n     * Defines if sort just emit events.\n     */\n    sortExternal: Boolean\n  },\n\n  data () {\n    return {\n      sorter: null,\n      sortment: 'ascending'\n    }\n  },\n\n  computed: {\n    $sortedRows () {\n      const isSorted = is(this.sorter, 'Number')\n      if (!isSorted || this.sortExternal) {\n        return [ ...this[rows] ]\n      }\n\n      const sorted = [ ...this[rows] ].sort((a, b) => this.$sort(a, b))\n      return sorted\n    }\n  },\n\n  methods: {\n    /**\n     * Check if column is sorting.\n     * @param {number} index\n     * @returns {boolean}\n     */\n    $isSorting (index) {\n      const isSorting = this.sorter === index\n      return isSorting\n    },\n\n    /**\n     * Check if a column is sortable.\n     * @param {number} index\n     * @returns {boolean}\n     */\n    $isSortable (index) {\n      const isSortable = !!this.$getSort(index)\n      return isSortable\n    },\n\n    /**\n     * Get column's sort setting.\n     * @param {number} index\n     * @returns {(boolean|function)}\n     */\n    $getSort (index) {\n      const col = this[cols][index]\n      const sort = getProperty('sort', [col, this._props])\n      return sort\n    },\n\n    /**\n     * Get column sort classes.\n     * @param {number} index\n     * @returns {(string|Array.<string, boolean>)[]}\n     */\n    $getSortClasses (index) {\n      const isSortable = this.$isSortable(index)\n      const isSorting = this.$isSorting(index)\n      const classes = {\n        '-sorting': isSorting,\n        '-sortable': isSortable,\n        '-unsortable': !isSortable,\n        ['-' + this.sortment]: isSorting\n      }\n      return classes\n    },\n\n    /**\n     * Get column arrow's.\n     * @param {number} index\n     * @returns {('▼'|'▲'|'')}\n     */\n    $getArrow (index) {\n      const isSorting = this.$isSorting(index)\n      if (!isSorting) return '▲'\n      const arrow = this.sortment === 'ascending' ? '▲' : '▼'\n      return arrow\n    },\n\n    /**\n     * Sort a column or change its sortment.\n     * @param {number} index\n     */\n    $setSorter (index) {\n      const isSorter = this.$isSorting(index)\n      const isSortable = this.$isSortable(index)\n\n      if (!isSortable) {\n        return\n      }\n\n      const column = this[cols][index]\n      const sortment = !isSorter || this.sortment === 'descending' ? 'ascending' : 'descending'\n      this.sortment = sortment\n      this.sorter = index\n      this.$emit('sort', { column, sortment })\n    },\n\n    /**\n     * Returns diference between values.\n     * This is the sort function.\n     * @param {object} rowA\n     * @param {object} rowB\n     * @returns {number}\n     */\n    $sort (rowA, rowB) {\n      const custom = this.$getSort(this.sorter)\n      const sort = is(custom, 'Function') ? custom : DEFAULT_SORT\n      const path = this[cols][this.sorter].field\n      const number = sort(get(rowA, path), get(rowB, path))\n      const result = number * (this.sortment === 'ascending' ? 1 : -1)\n      return result\n    }\n  }\n})\n\nexport default Sortable\n","<template>\n  <table :class=\"classy\">\n    <tr :class=\"[classy + '-row', '-header']\">\n      <th\n        v-if=\"selectable\"\n        :class=\"[classy + '-cell', '-header', '-clickable']\"\n      >\n        <input\n          type=\"checkbox\"\n          :class=\"[classy + '-select', '-all']\"\n          :checked=\"isSelectedAll\"\n          @click.prevent=\"selectAll\"\n        />\n      </th>\n\n      <th\n        v-for=\"(col, index) in cols\"\n        :key=\"index\"\n        :class=\"getClasses(index, 'header')\"\n        :style=\"getStyle(col)\"\n        :width=\"col.width || null\"\n        @click=\"$setSorter(index)\"\n      >\n        <span :class=\"classy + '-text'\">{{ getText(col, 'label') || empty }}</span>\n\n        <slot\n          name=\"sort-icon\"\n          :sortment=\"sortment\"\n          :sorted=\"$isSorting(index)\"\n          :arrow=\"$getArrow(index)\"\n        >\n          <span :class=\"classy + '-icon'\">{{ $getArrow(index) }}</span>\n        </slot>\n      </th>\n    </tr>\n\n    <tr\n      v-for=\"(row, rowIndex) in $sortedRows\"\n      :key=\"rowIndex\"\n      :class=\"[classy + '-row', '-content']\">\n\n      <th\n        v-if=\"selectable\"\n        :class=\"[classy + '-cell', '-content', '-clickable']\"\n        @click.prevent=\"select(row, $event)\"\n      >\n        <input\n          type=\"checkbox\"\n          :class=\"[classy + '-select', '-all']\"\n          :checked=\"isSelected(row)\"\n        />\n      </th>\n\n      <slot name=\"row\" :row=\"row\" :index=\"rowIndex\">\n        <td\n          v-for=\"(col, colIndex) in cols\"\n          :key=\"colIndex\"\n          :class=\"getClasses(colIndex, 'content')\"\n          :style=\"getStyle(col)\"\n          :width=\"col.width || null\"\n        >\n          <span :class=\"classy + '-text'\">{{ getText(row, col.field) || empty }}</span>\n        </td>\n      </slot>\n    </tr>\n  </table>\n</template>\n\n<script>\n  import is from './helpers/is'\n  import get from './helpers/get'\n  import toggle from './helpers/toggle'\n  import Alignable from './mixins/Alignable'\n  import Selectable from './mixins/Selectable'\n  import Sortable from './mixins/Sortable'\n  import { isContent } from './helpers/validators'\n\n  export default {\n    mixins: [ Sortable(), Alignable(), Selectable() ],\n    props: {\n      /**\n       * List of col's data.\n       */\n      cols: {\n        type: Array,\n        required: true,\n        validator: isContent\n      },\n\n      /**\n       * List of row's data.\n       */\n      rows: {\n        type: Array,\n        required: true,\n        validator: isContent\n      },\n\n      /**\n       * Empty cell's character.\n       */\n      empty: {\n        type: String,\n        default: ''\n      }\n    },\n\n    data () {\n      return {\n        classy: this.$options.name || 'data-tablee'\n      }\n    },\n\n    methods: {\n      /**\n       * Get cell's classes.\n       * @param {number} index\n       * @param {('header'|'content')} type\n       * @returns {(string|Object.<string, boolean>)[]}\n       */\n      getClasses (index, type) {\n        const custom = this.cols[index][type + 'Class']\n        const classes = [\n          custom,\n          '-' + type,\n          this.classy + '-cell',\n          this.$getSortClasses(index),\n          '-' + this.$getAlignment(index)\n        ]\n\n        return classes\n      },\n\n      /**\n       * Get cell's styles.\n       * @param {{ hidden: boolean, align: align }} col\n       * @returns {CSSStyleDeclaration}\n       */\n      getStyle (col) {\n        const style = {\n          textAlign: col.align || this.align,\n          display: col.hidden ? 'none' : undefined,\n        }\n        return style\n      },\n\n      /**\n       * Get value's label.\n       * @param {*} value\n       * @param {string} path\n       * @returns {string}\n       */\n      getText: get\n    },\n\n    /**\n     * Install DataTablee components.\n     * @param {Vue} Vue\n     * @param {{ name: string }} [options]\n     */\n    install (Vue, { name = 'data-tablee' } = {}) {\n      Vue.component(name, this)\n    }\n  }\n</script>\n\n<style lang=\"scss\">\n  @import url('https://fonts.googleapis.com/css?family=Nunito+Sans:400,700');\n\n  .data-tablee {\n    overflow: hidden;\n    border: 1px solid #eaedef;\n    border-radius: 5px;\n    border-spacing: 0;\n  }\n\n  .data-tablee-cell {\n    position: relative;\n    min-height: calc(27px + 4px);\n    padding: 18px;\n    border-top: 1px solid #eaedef;\n\n    .data-tablee-row:first-child > & { border-top: 0; }\n\n    &::before {\n      position: absolute;\n      left: 0;\n      top: 50%;\n      display: block;\n      width: 1px;\n      height: 27px;\n      background-color: #eaedef;\n      transform: translateY(-50%);\n      content: '';\n    }\n\n    &:first-child::before { content: none; }\n\n    &.-right { text-align: right; }\n    &.-left { text-align: left; }\n    &.-center { text-align: center; }\n    &.-clickable { cursor: pointer; }\n  }\n\n  .data-tablee-text {\n    font-size: 13px;\n    font-family: 'Nunito Sans', sans-serif;\n    font-weight: 400;\n    color: #5e6684;\n  }\n\n  .data-tablee-cell.-header {\n    background-color: #fdfdfd;\n\n    & > .data-tablee-text,\n    & > .data-tablee-icon {\n      display: inline-block;\n      font-size: 12px;\n      font-family: 'Nunito Sans', sans-serif;\n      font-weight: 700;\n      text-transform: uppercase;\n      color: #bec0d3;\n    }\n\n    & > .data-tablee-icon {\n      opacity: 0;\n      transition: opacity .3s ease,\n                  transform .3s ease;\n    }\n\n    &.-sortable {\n      cursor: pointer;\n\n      & > .data-tablee-icon { opacity: .2; }\n\n      &:hover > .data-tablee-icon { opacity: .8; }\n\n      &:active > .data-tablee-icon {\n        transition: transform .1s ease;\n        transform: scale(1.5);\n      }\n\n      &.-right { padding-right: 6px; }\n    }\n\n    &.-sorting > .data-tablee-icon { opacity: 1; }\n  }\n\n  .data-tablee-text { line-height: 1; }\n</style>\n\n","import { getProperty } from '../helpers/get'\nimport { isAlignment } from '../helpers/validators'\n\nconst Alignable = ({ cols = 'cols' } = {}) => ({\n  props: {\n    /**\n     * Default cell's alignment.\n     */\n    align: {\n      type: String,\n      default: 'left',\n      validator: isAlignment\n    }\n  },\n  methods: {\n    /**\n     * Get column's alignment.\n     * @param {number} index\n     * @returns {('right'|'left'|'center')}\n     */\n    $getAlignment (index) {\n      const col = this[cols][index]\n      const alignment = getProperty('align', [col, this._props], isAlignment)\n      return alignment\n    }\n  }\n})\n\nexport default Alignable\n"],"names":["values","value","constructor","Object","prototype","toString","call","getValue","object","property","is","hasOwnProperty","get","path","split","getProperties","reduce","DEFAULT_VALIDATE","getProperty","name","objects","validate","map","find","isAlignment","includes","isContent","every","_slicedToArray","arr","i","Array","isArray","Symbol","iterator","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","length","err","_sliceIterator","TypeError","_toConsumableArray","arr2","from","DEFAULT_SORT","a","b","String","localeCompare","cols","rows","Boolean","Function","this","sorter","sortExternal","sort","_this","$sort","index","$getSort","col","_props","obj","key","isSortable","$isSortable","isSorting","$isSorting","sortment","defineProperty","enumerable","configurable","writable","isSorter","column","$emit","rowA","rowB","custom","field","Sortable","Alignable","isSelectedAll","selectedRows","row","isSelected","selected","event","shiftKey","lastClicked","multipleSelect","filter","emitSelected","indexOf","start","end","range","fill","_","Selectable","$options","type","classy","$getSortClasses","$getAlignment","align","hidden","Vue","component"],"mappings":"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"}